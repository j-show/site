<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="jShow's Home, share experiences and ideas"><meta name="keywords" content="jShow, jshow, Node.js, nodejs"><meta http-equiv="Expires" content="0"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Cache-control" content="no-cache"><meta http-equiv="Cache" content="no-cache"><title>Promise与异步的讲解 - jShow's Home</title><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://www.googletagmanager.com/gtag/js?id=UA-141766789-1" async></script><script src="/images/global.js"></script><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><label class="navi-button light" for="navi">菜单</label><div class="main-navication"><div class="owner"><div class="ml30 slider" id="languager"><a class="selected zh" href="javascript:void(0);" tag="zh">中文</a><div class="lang_block" style="display:none;"><a class="en" href="/en/20190619/2309/" tag="en">English</a><a class="zh" href="/zh/20190619/2309/" tag="zh">中文</a></div></div><a href="/zh/index.html" target="_self"><i class="icon home"></i><span>首页</span></a><a href="https://github.com/j-show/jshow" target="_blank"><i class="icon github"></i><span>Github</span></a><a href="/tags/index-zh.html" target="_self"><i class="icon tag"></i><span>标签</span></a><a href="/categories/index-zh.html" target="_self"><i class="icon category"></i><span>类别</span></a><a href="/about/index-zh.html" target="_self"><i class="icon author"></i><span>关于我们</span></a></div></div><div class="wrapper" id="wrap"><div class="post-header"><div class="background"><img src="/images/post_background.jpg"></div><div class="post-title"><h1 class="title">Promise与异步的讲解</h1><ul class="meta"><li><i class="icon author"></i>jshow</li><li><i class="icon clock"></i><script>document.write(calcTime(1560925819148));</script></li><li><i class="icon calendar"></i>June 19, 2019</li></ul></div></div><div class="article-content" style="max-width:800px"><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#起源"><span class="post-toc-number">1.</span> <span class="post-toc-text">起源</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#无限回调"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">无限回调</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#延迟对象-Deferred"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">延迟对象(Deferred)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#生成器-Generator"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">生成器(Generator)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Promise"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">Promise</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#async-await"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">async/await</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#优化"><span class="post-toc-number">2.</span> <span class="post-toc-text">优化</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#总结"><span class="post-toc-number">3.</span> <span class="post-toc-text">总结</span></a></li></ol>
<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>自从js引入了异步这个概念，众多的先驱想出了种种方式来让代码更简单，我们简单回顾下都有哪些。</p>
<h2 id="无限回调"><a href="#无限回调" class="headerlink" title="无限回调"></a><code>无限回调</code></h2><p>这是最早的异步解决方案，通过回调函数的无限嵌套来实现，不是把自己绕晕，就是把需求绕晕</p>
<blockquote>
<p>据说当时码农的KPI非常轻松，随随便便一个需求就能堆砌出几百行代码，代码冗余可见一斑。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">num,callback</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		callback()</span><br><span class="line">	&#125;, num * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">Test(<span class="number">10</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"10 seconds after"</span>);</span><br><span class="line">	</span><br><span class="line">	Test(<span class="number">2</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"12 seconds after"</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>-</p>
<h2 id="延迟对象-Deferred"><a href="#延迟对象-Deferred" class="headerlink" title="延迟对象(Deferred)"></a><code>延迟对象(Deferred)</code></h2><p>这是由<code>jQuery</code>库率先提出的延迟对象方案。</p>
<blockquote>
<p>延迟对象粗略分为<code>成功(done)</code>、<code>错误(fail)</code>、<code>总是(always)</code>状态，通过回调函数，在不同状态下执行。</p>
</blockquote>
<pre><code>允许同时注册相同的状态，done和fail状态互斥，只允许触发一次状态
即使状态先触发，后注册函数，也会收到相应触发

特别说明：所有状态的回调函数，是同步顺序执行的</code></pre><blockquote>
<p>本质是通过状态及建立了一个回调函数列表，还属于回调函数范畴，但代码上看着就非常舒服了。</p>
</blockquote>
<blockquote>
<p>jQuery的延迟对象当初一度让混乱的回调函数得以规范化，算是一股清流！jShow中的异步机制在操作形式上借鉴了一部分，是对前辈的致敬。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> dtd = $.Deferred();</span><br><span class="line">	</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		dtd.resolve(<span class="string">"n seconds after"</span>);</span><br><span class="line">	&#125;, num * <span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	dtd.promise();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">Test()</span><br><span class="line">	.done(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(val, <span class="number">1</span>); <span class="comment">// n seconds after 1</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.done(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(val, <span class="number">2</span>); <span class="comment">// n seconds after 2</span></span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>


<p>-</p>
<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a><code>生成器(Generator)</code></h2><p>这是ES2015标准后产生的异步解决方案，构建了一个可以分步执行的函数块，使用者可以自己选择什么时候执行下一步。</p>
<blockquote>
<p>分步执行的方式，有点像调试环境下的分步跟踪。</p>
</blockquote>
<blockquote>
<p>生成器本身并不是为了解决异步问题出现的，但是著名的<code>tj</code>写了个<code>co</code>库，让生成器函数可以自动运行，两项结合让它完全可以运用于异步函数的编写。</p>
</blockquote>
<blockquote>
<p>但是因为生成器非常生涩的编码方式和复杂逻辑，让人很难喜欢起来，所以使用者非常少。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> d;</span><br><span class="line">	</span><br><span class="line">	d = <span class="keyword">yield</span> Test();</span><br><span class="line">	<span class="built_in">console</span>.log(d);</span><br><span class="line">	</span><br><span class="line">	d = <span class="keyword">yield</span> Test();</span><br><span class="line">	<span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>生成器函数引入了<code>function*</code>和<code>yield</code>这种特殊语法结构，<code>yield</code>必须在<code>function*</code>内部才有效</p>
<p>-</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><code>Promise</code></h2><p>可能是generator让人太难以接受，ES6标准有了promise，可以说他是官方版本的Deferred，通过在参数中的<code>resovle</code>和<code>reject</code>，来决定最终状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			resovle(<span class="string">"n seconds after"</span>);</span><br><span class="line">		&#125;, num * <span class="number">1000</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">Test(<span class="number">10</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(val); <span class="comment">// n secord after</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>Promise在使用时还是需要用到类似回调函数的代码结构。</p>
<p><code>then</code>/<code>catch</code>函数类似于延迟对象的回调注册，但每次调用都会返回新的Promise对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">let</span> b = a.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">	</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(a, b)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>毫无疑问，基于promise的理解每个人多少有点出入，这也造成了<code>npm</code>平台上针对promise的实现，让人有点无所适从</p>
</blockquote>
<blockquote>
<p>之所以这么说，并不是说各种库中promise的代码有问题，而是针对异步的理解和promise的使用存在差异，所以这里不针对promise单独说明，而是与async/await合并说明</p>
</blockquote>
<p><strong><em>基于jShow的异步机制和理解，我们认为单独讨论promise没有意义</em></strong></p>
<p>-</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h2><p>ES7提出了正式的异步解决方案，并引入了<code>async/await</code>语法结构。</p>
<blockquote>
<p>与生成器的<code>function*</code>和<code>yield</code>语法类似，await关键字只允许在async函数内部使用</p>
</blockquote>
<blockquote>
<p>不管是普通函数(function)、异步函数(async function)，只要函数返回值是promise对象，使用await就会自动进行异步操作，所差别的就是普通函数内部不允许使用await关键字。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (num === <span class="number">10</span>) resovle(<span class="string">"n seconds after"</span>);</span><br><span class="line">			<span class="keyword">else</span> reject(<span class="string">"return reject"</span>);</span><br><span class="line">		&#125;, num * <span class="number">1000</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> v1 = <span class="keyword">await</span> Test(<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(val); <span class="comment">// n secord after</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e); <span class="comment">// return reject</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">let</span> v2 = <span class="keyword">await</span> Test(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(val) <span class="comment">// n secord after</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>


<p>这里说明3个重要点:</p>
<ol>
<li><p>await关键字必须在async函数内部使用，否则会造成编译错误</p>
</li>
<li><p>await关键字可以理解成一个内置函数</p>
<blockquote>
<p>await Test(10) 可以理解成 await(Test(10))</p>
</blockquote>
<blockquote>
<p>await处理的是Test(10)的返回值，当返回值是promise对象时会异步方式等待resovle状态结果，当返回值时是其他类型时直接得到返回值</p>
</blockquote>
<blockquote>
<p>await是异步方式执行，不会造成代码阻塞，类似于线程切换的控制权转移</p>
</blockquote>
</li>
<li><p>await无法处理promise对象的reject状态，当然触发reject状态时会抛出异常需要用try…catch处理</p>
</li>
</ol>
<p><strong>ES6的Promise为异步的单步操作，提供了很好的状态机实现方式。但是它无法满足整个异步流程，链式语法不过是一个ES6版本的<code>无限回调</code>。</strong></p>
<p><strong>ES7的async很好的解决了异步流程的控制。promise处理状态控制，async串联异步流程，把异步流程以同步代码的方式编写，代码会非常的简洁明了。</strong></p>
<blockquote>
<p>唯一的问题，即使需要解释器支持async语法。</p>
</blockquote>
<blockquote>
<p>如果放弃ie8-的游览器，好像也不是什么大事</p>
</blockquote>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>jShow针对异步流程，用自己的优化方案，其初衷是希望代码更简洁，可读性更强。</p>
<p>通过上面<a href="#async-await">async/await</a>的简述，应该都清楚了异步编程的一些注意事项。从中我们不难发现，async在流程控制上已经很简洁了，但是在兼容性上和Promise上面又有点复杂。</p>
<ul>
<li><p>基础</p>
<p>  针对普通运用，jShow对Promise进行该扩展，让他使用起来更加简洁</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> dtd = jShow.Deferred(<span class="literal">true</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">let</span> rs = <span class="keyword">await</span> Test(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">console</span>.log(rs); <span class="comment">// ok;</span></span><br><span class="line">	</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (num === <span class="number">10</span>) dtd.resolve(<span class="string">"ok"</span>);</span><br><span class="line">		<span class="keyword">else</span> dtd.reject(<span class="string">"error"</span>, num);</span><br><span class="line">	&#125;, num * <span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dtd.promise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">await</span> Test(<span class="number">5</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>  -</p>
<p>  通过针对Promise对象的扩展，让promise对象事先确认，并在需要的时候进行状态设定，这完全突破了promise对象必须进行函数包裹的形式，让编码更加自由。</p>
<blockquote>
<p>jShow的Deferred允许绑定<code>最终函数</code>，<code>最终函数</code>允许在所有异步绑定事件执行完后再执行</p>
</blockquote>
<blockquote>
<p>jShow的Deferred有简单模式和复杂模式两种，简单模式是对于Promise对象的扩展，复杂模式则是在简单模式基础上可以针对绑定函数进行特殊限制</p>
</blockquote>
<p>  <strong><em>我们推荐，所有await操作都被try…catch报告，以确保reject状态可以命中并处理</em></strong></p>
</li>
<li><p>强制普通函数内部使用</p>
</li>
</ul>
<p>在实际开发中，我们经常平台某个异步操作，必须在普通函数内部使用的情况，jShow的异步机制完全可以通过下列方式调用，而不用改变原始的异步函数</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> dtd = jShow.Deferred(<span class="literal">true</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">let</span> rs = <span class="keyword">await</span> Test(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">console</span>.log(rs); <span class="comment">// ok;</span></span><br><span class="line">	</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (num === <span class="number">10</span>) dtd.resolve(<span class="string">"ok"</span>);</span><br><span class="line">		<span class="keyword">else</span> dtd.reject(<span class="string">"error"</span>, num);</span><br><span class="line">	&#125;, num * <span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dtd.promise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test(<span class="number">5</span>)</span><br><span class="line">	.done(<span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">	&#125;)</span><br><span class="line">	.fail(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>转换</p>
<p>  因为需要用到别人编写的函数，不确定对方的操作形式时，可以简单的使用转换函数包裹，来达到相同的目的</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// generator function, do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = jShow.Async(Test1);</span><br><span class="line"><span class="comment">//test1 is async function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//normal function, do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = jShow.Done(Test2);</span><br><span class="line"><span class="comment">//test2 is async function</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>仔细想一下异步编程甚至整个node.js，之所以会让人觉得学习成本很高，代码形式差异很大。完全是因为ECMAScript的责任，ES版本迭代的过程中，完全没有相对应的指导。甚至是官方说明都比较模糊，导致了大部分人对于理解的偏差非常大。</p>
<p>之前通过阅读别人的代码，发现大部分陷入Promise问题的，并不是他对于异步理解不对，通常都是他在强硬的用promise状态机来解决异步流程控制，这导致代码冗余，而且流程让人很难接受。可能编码的当时ES7还未出现，也可能出现了但作者还没有时间去学习，甚至是考虑兼容，才造就了这样的情况，但不可否认，这给使用人留下了巨大的隐患和错误的导向。让越来越多的人接收到了错误的信息。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/zh/tags/explain">explain</a></li></ul></div><div class="categories"><i class="icon category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/zh/categories/jShow">jShow</a></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon home"></i></a></li><li><a href="/zh/20190612/1319/"><i class="icon arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/j-show/jshow" title="Github" target="_blank"><i class="icon github"></i></a></li><li><a href="https://twitter.com/jShow_OS" title="Twitter" target="_blank"><i class="icon twitter"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 jShow's Home<br><script type="text/javascript">analytics_google("UA-141766789-1")</script><script type="text/javascript">analytics_cnzz("1277700064")</script><small>POWER BY&nbsp;<a href="https://hexo.io" target="_blank">HEXO</a></small>&nbsp;|&nbsp;<small>THEME BY&nbsp;<a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><div id="dialog" style="display:none;"></div><script type="text/javascript">$(function () { $("#wrap").addClass("done"); $("#languager").Languager(); });</script></body></html>